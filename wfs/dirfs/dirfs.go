// Package dirfs provides an implementation of a filesystem (an fs.FS) that is writable.
package dirfs

import (
	"errors"
	"io/fs"
	"os"
	"path"

	"github.com/energietransitie/twomes-manual-server/wfs"
)

var (
	ErrEmptyRoot = errors.New("dirfs with empty root")
)

// New returns a file system (an fs.FS) for the tree of files rooted at the directory dir.
func New(name string) fs.FS {
	return DirFS(name)
}

// DirFS is a filesystem (an fs.FS) for the tree of files rooted at the directory dir.
type DirFS string

// Open opens the named file.
// When Open returns an error, it should be of type *PathError
// with the Op field set to "open", the Path field set to name,
// and the Err field describing the problem.
func (dir DirFS) Open(name string) (fs.File, error) {
	fullPath, err := dir.join(name)
	if err != nil {
		return nil, err
	}
	return os.Open(fullPath)
}

// Stat returns a FileInfo describing the file.
// If there is an error, it should be of type *PathError.
func (dir DirFS) Stat(name string) (fs.FileInfo, error) {
	fullPath, err := dir.join(name)
	if err != nil {
		return nil, err
	}
	return os.Stat(fullPath)
}

// Create creates or truncates the named file. If the file already exists,
// it is truncated. If the file does not exist, it is created with mode 0666
// (before umask). If successful, methods on the returned File can
// be used for I/O; the associated file descriptor has mode O_RDWR.
// If there is an error, it will be of type *PathError.
func (dir DirFS) CreateFile(name string) (wfs.File, error) {
	fullPath, err := dir.join(name)
	if err != nil {
		return nil, err
	}
	return os.Create(fullPath)
}

// WriteFile writes data to the named file, creating it if necessary.
// If the file does not exist, WriteFile creates it with permissions perm (before umask);
// otherwise WriteFile truncates it before writing, without changing permissions.
// Since Writefile requires multiple system calls to complete, a failure mid-operation
// can leave the file in a partially written state.
func (dir DirFS) WriteFile(name string, data []byte, perm fs.FileMode) error {
	fullPath, err := dir.join(name)
	if err != nil {
		return err
	}
	return os.WriteFile(fullPath, data, perm)
}

// ReadFile reads the named file and returns its contents.
// A successful call returns a nil error, not io.EOF.
// (Because ReadFile reads the whole file, the expected EOF
// from the final Read is not treated as an error to be reported.)
//
// The caller is permitted to modify the returned byte slice.
// This method should return a copy of the underlying data.
func (dir DirFS) ReadFile(name string) ([]byte, error) {
	fullPath, err := dir.join(name)
	if err != nil {
		return nil, err
	}
	return os.ReadFile(fullPath)
}

// Mkdir creates a new directory with the specified name and permission
// bits (before umask).
// If there is an error, it will be of type *PathError.
func (dir DirFS) Mkdir(name string, perm fs.FileMode) error {
	fullPath, err := dir.join(name)
	if err != nil {
		return err
	}
	return os.Mkdir(fullPath, perm)
}

// MkdirAll creates a directory named path,
// along with any necessary parents, and returns nil,
// or else returns an error.
// The permission bits perm (before umask) are used for all
// directories that MkdirAll creates.
// If path is already a directory, MkdirAll does nothing
// and returns nil.
func (dir DirFS) MkdirAll(path string, perm fs.FileMode) error {
	fullPath, err := dir.join(path)
	if err != nil {
		return err
	}
	return os.MkdirAll(fullPath, perm)
}

// MkdirTemp creates a new temporary directory in the directory dir
// and returns the pathname of the new directory.
// The new directory's name is generated by adding a random string to the end of pattern.
// If pattern includes a "*", the random string replaces the last "*" instead.
// If dir is the empty string, MkdirTemp returns an error.
// Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
// It is the caller's responsibility to remove the directory when it is no longer needed.
func (dir DirFS) MkdirTemp(path string, pattern string) (string, error) {
	fullPath, err := dir.join(path)
	if err != nil {
		return "", err
	}
	return os.MkdirTemp(fullPath, pattern)
}

// Remove removes the named file or (empty) directory.
// If there is an error, it will be of type *PathError.
func (dir DirFS) Remove(name string) error {
	fullPath, err := dir.join(name)
	if err != nil {
		return err
	}
	return os.Remove(fullPath)
}

// RemoveAll removes path and any children it contains.
// It removes everything it can but returns the first error
// it encounters. If the path does not exist, RemoveAll
// returns nil (no error).
// If there is an error, it will be of type *PathError.
func (dir DirFS) RemoveAll(path string) error {
	fullPath, err := dir.join(path)
	if err != nil {
		return err
	}
	return os.RemoveAll(fullPath)
}

// join returns the path for name in wfs.
func (dir DirFS) join(name string) (string, error) {
	if dir == "" {
		return "", &fs.PathError{Op: "open", Path: name, Err: ErrEmptyRoot}
	}
	if !fs.ValidPath(name) {
		return "", &fs.PathError{Op: "open", Path: name, Err: fs.ErrInvalid}
	}

	return path.Join(string(dir), name), nil
}
