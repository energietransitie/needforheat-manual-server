package wfs

import (
	"io/fs"
)

// MkdirFS is the interface implemented by a file system
// that provides an implementation of Mkdir.
type MkdirFS interface {
	fs.FS

	// Mkdir creates a new directory with the specified name and permission
	// bits (before umask).
	// If there is an error, it will be of type *PathError.
	Mkdir(name string, perm fs.FileMode) error
}

// Mkdir creates a new directory with the specified name and permission
// bits (before umask).
// If there is an error, it will be of type *PathError.
func Mkdir(fsys fs.FS, name string, perm fs.FileMode) error {
	if fsys, ok := fsys.(MkdirFS); ok {
		return fsys.Mkdir(name, perm)
	}
	return &fs.PathError{Op: "mkdir", Path: name, Err: ErrInterfaceNotImplemented}
}

// MkdirAllFS is the interface implemented by a file system
// that provides an implementation of MkdirAll.
type MkdirAllFS interface {
	fs.FS

	// MkdirAll creates a directory named path,
	// along with any necessary parents, and returns nil,
	// or else returns an error.
	// The permission bits perm (before umask) are used for all
	// directories that MkdirAll creates.
	// If path is already a directory, MkdirAll does nothing
	// and returns nil.
	MkdirAll(path string, perm fs.FileMode) error
}

// MkdirAll creates a directory named path,
// along with any necessary parents, and returns nil,
// or else returns an error.
// The permission bits perm (before umask) are used for all
// directories that MkdirAll creates.
// If path is already a directory, MkdirAll does nothing
// and returns nil.
func MkdirAll(fsys fs.FS, path string, perm fs.FileMode) error {
	if fsys, ok := fsys.(MkdirAllFS); ok {
		return fsys.MkdirAll(path, perm)
	}
	return &fs.PathError{Op: "mkdirall", Path: path, Err: ErrInterfaceNotImplemented}
}

// MkdirTempFS is the interface implemented by a file system
// that provides an implementation of MkdirTemp.
type MkdirTempFS interface {
	fs.FS

	// MkdirTemp creates a new temporary directory in the directory dir
	// and returns the pathname of the new directory.
	// The new directory's name is generated by adding a random string to the end of pattern.
	// If pattern includes a "*", the random string replaces the last "*" instead.
	// If dir is the empty string, MkdirTemp needs to return an error.
	// Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
	// It is the caller's responsibility to remove the directory when it is no longer needed.
	MkdirTemp(path, pattern string) (string, error)
}

// MkdirTemp creates a new temporary directory in the directory dir
// and returns the pathname of the new directory.
// The new directory's name is generated by adding a random string to the end of pattern.
// If pattern includes a "*", the random string replaces the last "*" instead.
// If dir is the empty string, MkdirTemp returns an error.
// Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
// It is the caller's responsibility to remove the directory when it is no longer needed.
func MkdirTemp(fsys fs.FS, path, pattern string) (string, error) {
	if fsys, ok := fsys.(MkdirTempFS); ok {
		return fsys.MkdirTemp(path, pattern)
	}
	return "", &fs.PathError{Op: "mkdirtemp", Path: path, Err: ErrInterfaceNotImplemented}
}

// RemoveAllFS is the interface implemented by a file system
// that provides an implementation of RemoveAll.
type RemoveAllFS interface {
	fs.FS

	// RemoveAll removes path and any children it contains.
	// It removes everything it can but returns the first error
	// it encounters. If the path does not exist, RemoveAll
	// returns nil (no error).
	// If there is an error, it will be of type *PathError.
	RemoveAll(path string) error
}

// RemoveAll removes path and any children it contains.
// It removes everything it can but returns the first error
// it encounters. If the path does not exist, RemoveAll
// returns nil (no error).
// If there is an error, it will be of type *PathError.
func RemoveAll(fsys fs.FS, name string) error {
	if fsys, ok := fsys.(RemoveAllFS); ok {
		return fsys.RemoveAll(name)
	}
	return &fs.PathError{Op: "removeall", Path: name, Err: ErrInterfaceNotImplemented}
}
